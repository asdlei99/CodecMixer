// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AVMixer2BizsMessage.proto

#ifndef PROTOBUF_AVMixer2BizsMessage_2eproto__INCLUDED
#define PROTOBUF_AVMixer2BizsMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

class CCNState;
class CCNUser;
class CCNNotify;
class CCNMessage;

// ===================================================================

class CCNState : public ::google::protobuf::Message {
 public:
  CCNState();
  virtual ~CCNState();

  CCNState(const CCNState& from);

  inline CCNState& operator=(const CCNState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNState& default_instance();

  void Swap(CCNState* other);

  // implements Message ----------------------------------------------

  CCNState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNState& from);
  void MergeFrom(const CCNState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uiCur = 1;
  inline bool has_uicur() const;
  inline void clear_uicur();
  static const int kUiCurFieldNumber = 1;
  inline ::google::protobuf::uint32 uicur() const;
  inline void set_uicur(::google::protobuf::uint32 value);

  // required uint32 uiMax = 2;
  inline bool has_uimax() const;
  inline void clear_uimax();
  static const int kUiMaxFieldNumber = 2;
  inline ::google::protobuf::uint32 uimax() const;
  inline void set_uimax(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CCNState)
 private:
  inline void set_has_uicur();
  inline void clear_has_uicur();
  inline void set_has_uimax();
  inline void clear_has_uimax();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uicur_;
  ::google::protobuf::uint32 uimax_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNState* default_instance_;
};
// -------------------------------------------------------------------

class CCNUser : public ::google::protobuf::Message {
 public:
  CCNUser();
  virtual ~CCNUser();

  CCNUser(const CCNUser& from);

  inline CCNUser& operator=(const CCNUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNUser& default_instance();

  void Swap(CCNUser* other);

  // implements Message ----------------------------------------------

  CCNUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNUser& from);
  void MergeFrom(const CCNUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 identity = 2;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 2;
  inline ::google::protobuf::uint32 identity() const;
  inline void set_identity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CCNUser)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_identity();
  inline void clear_has_identity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 identity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNUser* default_instance_;
};
// -------------------------------------------------------------------

class CCNNotify : public ::google::protobuf::Message {
 public:
  CCNNotify();
  virtual ~CCNNotify();

  CCNNotify(const CCNNotify& from);

  inline CCNNotify& operator=(const CCNNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNNotify& default_instance();

  void Swap(CCNNotify* other);

  // implements Message ----------------------------------------------

  CCNNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNNotify& from);
  void MergeFrom(const CCNNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline const ::std::string& sessionid() const;
  inline void set_sessionid(const ::std::string& value);
  inline void set_sessionid(const char* value);
  inline void set_sessionid(const void* value, size_t size);
  inline ::std::string* mutable_sessionid();
  inline ::std::string* release_sessionid();
  inline void set_allocated_sessionid(::std::string* sessionid);

  // optional string config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // repeated .CCNUser user = 3;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::CCNUser& user(int index) const;
  inline ::CCNUser* mutable_user(int index);
  inline ::CCNUser* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::CCNUser >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::CCNUser >*
      mutable_user();

  // @@protoc_insertion_point(class_scope:CCNNotify)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sessionid_;
  ::std::string* config_;
  ::google::protobuf::RepeatedPtrField< ::CCNUser > user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNNotify* default_instance_;
};
// -------------------------------------------------------------------

class CCNMessage : public ::google::protobuf::Message {
 public:
  CCNMessage();
  virtual ~CCNMessage();

  CCNMessage(const CCNMessage& from);

  inline CCNMessage& operator=(const CCNMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNMessage& default_instance();

  void Swap(CCNMessage* other);

  // implements Message ----------------------------------------------

  CCNMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNMessage& from);
  void MergeFrom(const CCNMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CCNState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::CCNState& state() const;
  inline ::CCNState* mutable_state();
  inline ::CCNState* release_state();
  inline void set_allocated_state(::CCNState* state);

  // optional .CCNNotify notify = 2;
  inline bool has_notify() const;
  inline void clear_notify();
  static const int kNotifyFieldNumber = 2;
  inline const ::CCNNotify& notify() const;
  inline ::CCNNotify* mutable_notify();
  inline ::CCNNotify* release_notify();
  inline void set_allocated_notify(::CCNNotify* notify);

  // @@protoc_insertion_point(class_scope:CCNMessage)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_notify();
  inline void clear_has_notify();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CCNState* state_;
  ::CCNNotify* notify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// CCNState

// required uint32 uiCur = 1;
inline bool CCNState::has_uicur() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNState::set_has_uicur() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNState::clear_has_uicur() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNState::clear_uicur() {
  uicur_ = 0u;
  clear_has_uicur();
}
inline ::google::protobuf::uint32 CCNState::uicur() const {
  return uicur_;
}
inline void CCNState::set_uicur(::google::protobuf::uint32 value) {
  set_has_uicur();
  uicur_ = value;
}

// required uint32 uiMax = 2;
inline bool CCNState::has_uimax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNState::set_has_uimax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNState::clear_has_uimax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNState::clear_uimax() {
  uimax_ = 0u;
  clear_has_uimax();
}
inline ::google::protobuf::uint32 CCNState::uimax() const {
  return uimax_;
}
inline void CCNState::set_uimax(::google::protobuf::uint32 value) {
  set_has_uimax();
  uimax_ = value;
}

// -------------------------------------------------------------------

// CCNUser

// optional string uid = 1;
inline bool CCNUser::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNUser::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNUser::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNUser::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CCNUser::uid() const {
  return *uid_;
}
inline void CCNUser::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CCNUser::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CCNUser::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNUser::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CCNUser::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNUser::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 identity = 2;
inline bool CCNUser::has_identity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNUser::set_has_identity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNUser::clear_has_identity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNUser::clear_identity() {
  identity_ = 0u;
  clear_has_identity();
}
inline ::google::protobuf::uint32 CCNUser::identity() const {
  return identity_;
}
inline void CCNUser::set_identity(::google::protobuf::uint32 value) {
  set_has_identity();
  identity_ = value;
}

// -------------------------------------------------------------------

// CCNNotify

// required bytes sessionid = 1;
inline bool CCNNotify::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNNotify::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNNotify::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNNotify::clear_sessionid() {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    sessionid_->clear();
  }
  clear_has_sessionid();
}
inline const ::std::string& CCNNotify::sessionid() const {
  return *sessionid_;
}
inline void CCNNotify::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void CCNNotify::set_sessionid(const char* value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void CCNNotify::set_sessionid(const void* value, size_t size) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNNotify::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  return sessionid_;
}
inline ::std::string* CCNNotify::release_sessionid() {
  clear_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionid_;
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNNotify::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionid_;
  }
  if (sessionid) {
    set_has_sessionid();
    sessionid_ = sessionid;
  } else {
    clear_has_sessionid();
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string config = 2;
inline bool CCNNotify::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNNotify::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNNotify::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNNotify::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& CCNNotify::config() const {
  return *config_;
}
inline void CCNNotify::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void CCNNotify::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void CCNNotify::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNNotify::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* CCNNotify::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNNotify::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .CCNUser user = 3;
inline int CCNNotify::user_size() const {
  return user_.size();
}
inline void CCNNotify::clear_user() {
  user_.Clear();
}
inline const ::CCNUser& CCNNotify::user(int index) const {
  return user_.Get(index);
}
inline ::CCNUser* CCNNotify::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::CCNUser* CCNNotify::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CCNUser >&
CCNNotify::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::CCNUser >*
CCNNotify::mutable_user() {
  return &user_;
}

// -------------------------------------------------------------------

// CCNMessage

// optional .CCNState state = 1;
inline bool CCNMessage::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNMessage::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNMessage::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNMessage::clear_state() {
  if (state_ != NULL) state_->::CCNState::Clear();
  clear_has_state();
}
inline const ::CCNState& CCNMessage::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::CCNState* CCNMessage::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::CCNState;
  return state_;
}
inline ::CCNState* CCNMessage::release_state() {
  clear_has_state();
  ::CCNState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_state(::CCNState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .CCNNotify notify = 2;
inline bool CCNMessage::has_notify() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNMessage::set_has_notify() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNMessage::clear_has_notify() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNMessage::clear_notify() {
  if (notify_ != NULL) notify_->::CCNNotify::Clear();
  clear_has_notify();
}
inline const ::CCNNotify& CCNMessage::notify() const {
  return notify_ != NULL ? *notify_ : *default_instance_->notify_;
}
inline ::CCNNotify* CCNMessage::mutable_notify() {
  set_has_notify();
  if (notify_ == NULL) notify_ = new ::CCNNotify;
  return notify_;
}
inline ::CCNNotify* CCNMessage::release_notify() {
  clear_has_notify();
  ::CCNNotify* temp = notify_;
  notify_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_notify(::CCNNotify* notify) {
  delete notify_;
  notify_ = notify;
  if (notify) {
    set_has_notify();
  } else {
    clear_has_notify();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AVMixer2BizsMessage_2eproto__INCLUDED
