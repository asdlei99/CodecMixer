// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MEPMessage.proto

#ifndef PROTOBUF_MEPMessage_2eproto__INCLUDED
#define PROTOBUF_MEPMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MEPMessage_2eproto();
void protobuf_AssignDesc_MEPMessage_2eproto();
void protobuf_ShutdownFile_MEPMessage_2eproto();

class MEPMessageBase;
class MEPMessage;
class MEPLoginRequest;
class MEPLoginResp;
class MEPJoinSessionRequest;
class MEPJoinSessionResp;
class MEPPingRequest;
class MEPPingResp;
class MEPEndSession;
class MEPIdentityInfos;

// ===================================================================

class MEPMessageBase : public ::google::protobuf::Message {
 public:
  MEPMessageBase();
  virtual ~MEPMessageBase();

  MEPMessageBase(const MEPMessageBase& from);

  inline MEPMessageBase& operator=(const MEPMessageBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPMessageBase& default_instance();

  void Swap(MEPMessageBase* other);

  // implements Message ----------------------------------------------

  MEPMessageBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPMessageBase& from);
  void MergeFrom(const MEPMessageBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MEPMessageBase)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPMessageBase* default_instance_;
};
// -------------------------------------------------------------------

class MEPMessage : public ::google::protobuf::Message {
 public:
  MEPMessage();
  virtual ~MEPMessage();

  MEPMessage(const MEPMessage& from);

  inline MEPMessage& operator=(const MEPMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPMessage& default_instance();

  void Swap(MEPMessage* other);

  // implements Message ----------------------------------------------

  MEPMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPMessage& from);
  void MergeFrom(const MEPMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MEPMessageBase base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::MEPMessageBase& base() const;
  inline ::MEPMessageBase* mutable_base();
  inline ::MEPMessageBase* release_base();
  inline void set_allocated_base(::MEPMessageBase* base);

  // optional .MEPLoginRequest login_request = 2;
  inline bool has_login_request() const;
  inline void clear_login_request();
  static const int kLoginRequestFieldNumber = 2;
  inline const ::MEPLoginRequest& login_request() const;
  inline ::MEPLoginRequest* mutable_login_request();
  inline ::MEPLoginRequest* release_login_request();
  inline void set_allocated_login_request(::MEPLoginRequest* login_request);

  // optional .MEPLoginResp login_resp = 3;
  inline bool has_login_resp() const;
  inline void clear_login_resp();
  static const int kLoginRespFieldNumber = 3;
  inline const ::MEPLoginResp& login_resp() const;
  inline ::MEPLoginResp* mutable_login_resp();
  inline ::MEPLoginResp* release_login_resp();
  inline void set_allocated_login_resp(::MEPLoginResp* login_resp);

  // optional .MEPJoinSessionRequest join_session_request = 4;
  inline bool has_join_session_request() const;
  inline void clear_join_session_request();
  static const int kJoinSessionRequestFieldNumber = 4;
  inline const ::MEPJoinSessionRequest& join_session_request() const;
  inline ::MEPJoinSessionRequest* mutable_join_session_request();
  inline ::MEPJoinSessionRequest* release_join_session_request();
  inline void set_allocated_join_session_request(::MEPJoinSessionRequest* join_session_request);

  // optional .MEPJoinSessionResp join_session_resp = 5;
  inline bool has_join_session_resp() const;
  inline void clear_join_session_resp();
  static const int kJoinSessionRespFieldNumber = 5;
  inline const ::MEPJoinSessionResp& join_session_resp() const;
  inline ::MEPJoinSessionResp* mutable_join_session_resp();
  inline ::MEPJoinSessionResp* release_join_session_resp();
  inline void set_allocated_join_session_resp(::MEPJoinSessionResp* join_session_resp);

  // optional .MEPPingRequest ping_request = 6;
  inline bool has_ping_request() const;
  inline void clear_ping_request();
  static const int kPingRequestFieldNumber = 6;
  inline const ::MEPPingRequest& ping_request() const;
  inline ::MEPPingRequest* mutable_ping_request();
  inline ::MEPPingRequest* release_ping_request();
  inline void set_allocated_ping_request(::MEPPingRequest* ping_request);

  // optional .MEPPingResp ping_resp = 7;
  inline bool has_ping_resp() const;
  inline void clear_ping_resp();
  static const int kPingRespFieldNumber = 7;
  inline const ::MEPPingResp& ping_resp() const;
  inline ::MEPPingResp* mutable_ping_resp();
  inline ::MEPPingResp* release_ping_resp();
  inline void set_allocated_ping_resp(::MEPPingResp* ping_resp);

  // optional .MEPEndSession end_session = 8;
  inline bool has_end_session() const;
  inline void clear_end_session();
  static const int kEndSessionFieldNumber = 8;
  inline const ::MEPEndSession& end_session() const;
  inline ::MEPEndSession* mutable_end_session();
  inline ::MEPEndSession* release_end_session();
  inline void set_allocated_end_session(::MEPEndSession* end_session);

  // optional .MEPIdentityInfos identity_infos = 9;
  inline bool has_identity_infos() const;
  inline void clear_identity_infos();
  static const int kIdentityInfosFieldNumber = 9;
  inline const ::MEPIdentityInfos& identity_infos() const;
  inline ::MEPIdentityInfos* mutable_identity_infos();
  inline ::MEPIdentityInfos* release_identity_infos();
  inline void set_allocated_identity_infos(::MEPIdentityInfos* identity_infos);

  // @@protoc_insertion_point(class_scope:MEPMessage)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_login_request();
  inline void clear_has_login_request();
  inline void set_has_login_resp();
  inline void clear_has_login_resp();
  inline void set_has_join_session_request();
  inline void clear_has_join_session_request();
  inline void set_has_join_session_resp();
  inline void clear_has_join_session_resp();
  inline void set_has_ping_request();
  inline void clear_has_ping_request();
  inline void set_has_ping_resp();
  inline void clear_has_ping_resp();
  inline void set_has_end_session();
  inline void clear_has_end_session();
  inline void set_has_identity_infos();
  inline void clear_has_identity_infos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MEPMessageBase* base_;
  ::MEPLoginRequest* login_request_;
  ::MEPLoginResp* login_resp_;
  ::MEPJoinSessionRequest* join_session_request_;
  ::MEPJoinSessionResp* join_session_resp_;
  ::MEPPingRequest* ping_request_;
  ::MEPPingResp* ping_resp_;
  ::MEPEndSession* end_session_;
  ::MEPIdentityInfos* identity_infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPMessage* default_instance_;
};
// -------------------------------------------------------------------

class MEPLoginRequest : public ::google::protobuf::Message {
 public:
  MEPLoginRequest();
  virtual ~MEPLoginRequest();

  MEPLoginRequest(const MEPLoginRequest& from);

  inline MEPLoginRequest& operator=(const MEPLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPLoginRequest& default_instance();

  void Swap(MEPLoginRequest* other);

  // implements Message ----------------------------------------------

  MEPLoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPLoginRequest& from);
  void MergeFrom(const MEPLoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 identity = 1;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 1;
  inline ::google::protobuf::uint32 identity() const;
  inline void set_identity(::google::protobuf::uint32 value);

  // optional bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MEPLoginRequest)
 private:
  inline void set_has_identity();
  inline void clear_has_identity();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::uint32 identity_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class MEPLoginResp : public ::google::protobuf::Message {
 public:
  MEPLoginResp();
  virtual ~MEPLoginResp();

  MEPLoginResp(const MEPLoginResp& from);

  inline MEPLoginResp& operator=(const MEPLoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPLoginResp& default_instance();

  void Swap(MEPLoginResp* other);

  // implements Message ----------------------------------------------

  MEPLoginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPLoginResp& from);
  void MergeFrom(const MEPLoginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int32 errcode() const;
  inline void set_errcode(::google::protobuf::int32 value);

  // optional string public_addr = 2;
  inline bool has_public_addr() const;
  inline void clear_public_addr();
  static const int kPublicAddrFieldNumber = 2;
  inline const ::std::string& public_addr() const;
  inline void set_public_addr(const ::std::string& value);
  inline void set_public_addr(const char* value);
  inline void set_public_addr(const char* value, size_t size);
  inline ::std::string* mutable_public_addr();
  inline ::std::string* release_public_addr();
  inline void set_allocated_public_addr(::std::string* public_addr);

  // optional uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // optional uint32 tick_delay = 4;
  inline bool has_tick_delay() const;
  inline void clear_tick_delay();
  static const int kTickDelayFieldNumber = 4;
  inline ::google::protobuf::uint32 tick_delay() const;
  inline void set_tick_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MEPLoginResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_public_addr();
  inline void clear_has_public_addr();
  inline void set_has_tick();
  inline void clear_has_tick();
  inline void set_has_tick_delay();
  inline void clear_has_tick_delay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* public_addr_;
  ::google::protobuf::int32 errcode_;
  ::google::protobuf::uint32 tick_;
  ::google::protobuf::uint32 tick_delay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPLoginResp* default_instance_;
};
// -------------------------------------------------------------------

class MEPJoinSessionRequest : public ::google::protobuf::Message {
 public:
  MEPJoinSessionRequest();
  virtual ~MEPJoinSessionRequest();

  MEPJoinSessionRequest(const MEPJoinSessionRequest& from);

  inline MEPJoinSessionRequest& operator=(const MEPJoinSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPJoinSessionRequest& default_instance();

  void Swap(MEPJoinSessionRequest* other);

  // implements Message ----------------------------------------------

  MEPJoinSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPJoinSessionRequest& from);
  void MergeFrom(const MEPJoinSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:MEPJoinSessionRequest)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPJoinSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class MEPJoinSessionResp : public ::google::protobuf::Message {
 public:
  MEPJoinSessionResp();
  virtual ~MEPJoinSessionResp();

  MEPJoinSessionResp(const MEPJoinSessionResp& from);

  inline MEPJoinSessionResp& operator=(const MEPJoinSessionResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPJoinSessionResp& default_instance();

  void Swap(MEPJoinSessionResp* other);

  // implements Message ----------------------------------------------

  MEPJoinSessionResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPJoinSessionResp& from);
  void MergeFrom(const MEPJoinSessionResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // optional int32 errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline ::google::protobuf::int32 errcode() const;
  inline void set_errcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MEPJoinSessionResp)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* session_id_;
  ::google::protobuf::int32 errcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPJoinSessionResp* default_instance_;
};
// -------------------------------------------------------------------

class MEPPingRequest : public ::google::protobuf::Message {
 public:
  MEPPingRequest();
  virtual ~MEPPingRequest();

  MEPPingRequest(const MEPPingRequest& from);

  inline MEPPingRequest& operator=(const MEPPingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPPingRequest& default_instance();

  void Swap(MEPPingRequest* other);

  // implements Message ----------------------------------------------

  MEPPingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPPingRequest& from);
  void MergeFrom(const MEPPingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tick = 1;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 1;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MEPPingRequest)
 private:
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPPingRequest* default_instance_;
};
// -------------------------------------------------------------------

class MEPPingResp : public ::google::protobuf::Message {
 public:
  MEPPingResp();
  virtual ~MEPPingResp();

  MEPPingResp(const MEPPingResp& from);

  inline MEPPingResp& operator=(const MEPPingResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPPingResp& default_instance();

  void Swap(MEPPingResp* other);

  // implements Message ----------------------------------------------

  MEPPingResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPPingResp& from);
  void MergeFrom(const MEPPingResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tick = 1;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 1;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // optional uint32 delay = 2;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 2;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MEPPingResp)
 private:
  inline void set_has_tick();
  inline void clear_has_tick();
  inline void set_has_delay();
  inline void clear_has_delay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tick_;
  ::google::protobuf::uint32 delay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPPingResp* default_instance_;
};
// -------------------------------------------------------------------

class MEPEndSession : public ::google::protobuf::Message {
 public:
  MEPEndSession();
  virtual ~MEPEndSession();

  MEPEndSession(const MEPEndSession& from);

  inline MEPEndSession& operator=(const MEPEndSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPEndSession& default_instance();

  void Swap(MEPEndSession* other);

  // implements Message ----------------------------------------------

  MEPEndSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPEndSession& from);
  void MergeFrom(const MEPEndSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 streams = 1;
  inline bool has_streams() const;
  inline void clear_streams();
  static const int kStreamsFieldNumber = 1;
  inline ::google::protobuf::uint32 streams() const;
  inline void set_streams(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MEPEndSession)
 private:
  inline void set_has_streams();
  inline void clear_has_streams();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 streams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPEndSession* default_instance_;
};
// -------------------------------------------------------------------

class MEPIdentityInfos : public ::google::protobuf::Message {
 public:
  MEPIdentityInfos();
  virtual ~MEPIdentityInfos();

  MEPIdentityInfos(const MEPIdentityInfos& from);

  inline MEPIdentityInfos& operator=(const MEPIdentityInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MEPIdentityInfos& default_instance();

  void Swap(MEPIdentityInfos* other);

  // implements Message ----------------------------------------------

  MEPIdentityInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MEPIdentityInfos& from);
  void MergeFrom(const MEPIdentityInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 identities = 1 [packed = true];
  inline int identities_size() const;
  inline void clear_identities();
  static const int kIdentitiesFieldNumber = 1;
  inline ::google::protobuf::uint32 identities(int index) const;
  inline void set_identities(int index, ::google::protobuf::uint32 value);
  inline void add_identities(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      identities() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_identities();

  // repeated string uids = 2;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 2;
  inline const ::std::string& uids(int index) const;
  inline ::std::string* mutable_uids(int index);
  inline void set_uids(int index, const ::std::string& value);
  inline void set_uids(int index, const char* value);
  inline void set_uids(int index, const char* value, size_t size);
  inline ::std::string* add_uids();
  inline void add_uids(const ::std::string& value);
  inline void add_uids(const char* value);
  inline void add_uids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& uids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_uids();

  // @@protoc_insertion_point(class_scope:MEPIdentityInfos)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > identities_;
  mutable int _identities_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> uids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MEPMessage_2eproto();
  friend void protobuf_AssignDesc_MEPMessage_2eproto();
  friend void protobuf_ShutdownFile_MEPMessage_2eproto();

  void InitAsDefaultInstance();
  static MEPIdentityInfos* default_instance_;
};
// ===================================================================


// ===================================================================

// MEPMessageBase

// required uint32 type = 1;
inline bool MEPMessageBase::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPMessageBase::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPMessageBase::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPMessageBase::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 MEPMessageBase::type() const {
  return type_;
}
inline void MEPMessageBase::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 id = 2;
inline bool MEPMessageBase::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MEPMessageBase::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MEPMessageBase::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MEPMessageBase::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MEPMessageBase::id() const {
  return id_;
}
inline void MEPMessageBase::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// MEPMessage

// required .MEPMessageBase base = 1;
inline bool MEPMessage::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPMessage::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPMessage::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPMessage::clear_base() {
  if (base_ != NULL) base_->::MEPMessageBase::Clear();
  clear_has_base();
}
inline const ::MEPMessageBase& MEPMessage::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::MEPMessageBase* MEPMessage::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::MEPMessageBase;
  return base_;
}
inline ::MEPMessageBase* MEPMessage::release_base() {
  clear_has_base();
  ::MEPMessageBase* temp = base_;
  base_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_base(::MEPMessageBase* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .MEPLoginRequest login_request = 2;
inline bool MEPMessage::has_login_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MEPMessage::set_has_login_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MEPMessage::clear_has_login_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MEPMessage::clear_login_request() {
  if (login_request_ != NULL) login_request_->::MEPLoginRequest::Clear();
  clear_has_login_request();
}
inline const ::MEPLoginRequest& MEPMessage::login_request() const {
  return login_request_ != NULL ? *login_request_ : *default_instance_->login_request_;
}
inline ::MEPLoginRequest* MEPMessage::mutable_login_request() {
  set_has_login_request();
  if (login_request_ == NULL) login_request_ = new ::MEPLoginRequest;
  return login_request_;
}
inline ::MEPLoginRequest* MEPMessage::release_login_request() {
  clear_has_login_request();
  ::MEPLoginRequest* temp = login_request_;
  login_request_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_login_request(::MEPLoginRequest* login_request) {
  delete login_request_;
  login_request_ = login_request;
  if (login_request) {
    set_has_login_request();
  } else {
    clear_has_login_request();
  }
}

// optional .MEPLoginResp login_resp = 3;
inline bool MEPMessage::has_login_resp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MEPMessage::set_has_login_resp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MEPMessage::clear_has_login_resp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MEPMessage::clear_login_resp() {
  if (login_resp_ != NULL) login_resp_->::MEPLoginResp::Clear();
  clear_has_login_resp();
}
inline const ::MEPLoginResp& MEPMessage::login_resp() const {
  return login_resp_ != NULL ? *login_resp_ : *default_instance_->login_resp_;
}
inline ::MEPLoginResp* MEPMessage::mutable_login_resp() {
  set_has_login_resp();
  if (login_resp_ == NULL) login_resp_ = new ::MEPLoginResp;
  return login_resp_;
}
inline ::MEPLoginResp* MEPMessage::release_login_resp() {
  clear_has_login_resp();
  ::MEPLoginResp* temp = login_resp_;
  login_resp_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_login_resp(::MEPLoginResp* login_resp) {
  delete login_resp_;
  login_resp_ = login_resp;
  if (login_resp) {
    set_has_login_resp();
  } else {
    clear_has_login_resp();
  }
}

// optional .MEPJoinSessionRequest join_session_request = 4;
inline bool MEPMessage::has_join_session_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MEPMessage::set_has_join_session_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MEPMessage::clear_has_join_session_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MEPMessage::clear_join_session_request() {
  if (join_session_request_ != NULL) join_session_request_->::MEPJoinSessionRequest::Clear();
  clear_has_join_session_request();
}
inline const ::MEPJoinSessionRequest& MEPMessage::join_session_request() const {
  return join_session_request_ != NULL ? *join_session_request_ : *default_instance_->join_session_request_;
}
inline ::MEPJoinSessionRequest* MEPMessage::mutable_join_session_request() {
  set_has_join_session_request();
  if (join_session_request_ == NULL) join_session_request_ = new ::MEPJoinSessionRequest;
  return join_session_request_;
}
inline ::MEPJoinSessionRequest* MEPMessage::release_join_session_request() {
  clear_has_join_session_request();
  ::MEPJoinSessionRequest* temp = join_session_request_;
  join_session_request_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_join_session_request(::MEPJoinSessionRequest* join_session_request) {
  delete join_session_request_;
  join_session_request_ = join_session_request;
  if (join_session_request) {
    set_has_join_session_request();
  } else {
    clear_has_join_session_request();
  }
}

// optional .MEPJoinSessionResp join_session_resp = 5;
inline bool MEPMessage::has_join_session_resp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MEPMessage::set_has_join_session_resp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MEPMessage::clear_has_join_session_resp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MEPMessage::clear_join_session_resp() {
  if (join_session_resp_ != NULL) join_session_resp_->::MEPJoinSessionResp::Clear();
  clear_has_join_session_resp();
}
inline const ::MEPJoinSessionResp& MEPMessage::join_session_resp() const {
  return join_session_resp_ != NULL ? *join_session_resp_ : *default_instance_->join_session_resp_;
}
inline ::MEPJoinSessionResp* MEPMessage::mutable_join_session_resp() {
  set_has_join_session_resp();
  if (join_session_resp_ == NULL) join_session_resp_ = new ::MEPJoinSessionResp;
  return join_session_resp_;
}
inline ::MEPJoinSessionResp* MEPMessage::release_join_session_resp() {
  clear_has_join_session_resp();
  ::MEPJoinSessionResp* temp = join_session_resp_;
  join_session_resp_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_join_session_resp(::MEPJoinSessionResp* join_session_resp) {
  delete join_session_resp_;
  join_session_resp_ = join_session_resp;
  if (join_session_resp) {
    set_has_join_session_resp();
  } else {
    clear_has_join_session_resp();
  }
}

// optional .MEPPingRequest ping_request = 6;
inline bool MEPMessage::has_ping_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MEPMessage::set_has_ping_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MEPMessage::clear_has_ping_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MEPMessage::clear_ping_request() {
  if (ping_request_ != NULL) ping_request_->::MEPPingRequest::Clear();
  clear_has_ping_request();
}
inline const ::MEPPingRequest& MEPMessage::ping_request() const {
  return ping_request_ != NULL ? *ping_request_ : *default_instance_->ping_request_;
}
inline ::MEPPingRequest* MEPMessage::mutable_ping_request() {
  set_has_ping_request();
  if (ping_request_ == NULL) ping_request_ = new ::MEPPingRequest;
  return ping_request_;
}
inline ::MEPPingRequest* MEPMessage::release_ping_request() {
  clear_has_ping_request();
  ::MEPPingRequest* temp = ping_request_;
  ping_request_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_ping_request(::MEPPingRequest* ping_request) {
  delete ping_request_;
  ping_request_ = ping_request;
  if (ping_request) {
    set_has_ping_request();
  } else {
    clear_has_ping_request();
  }
}

// optional .MEPPingResp ping_resp = 7;
inline bool MEPMessage::has_ping_resp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MEPMessage::set_has_ping_resp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MEPMessage::clear_has_ping_resp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MEPMessage::clear_ping_resp() {
  if (ping_resp_ != NULL) ping_resp_->::MEPPingResp::Clear();
  clear_has_ping_resp();
}
inline const ::MEPPingResp& MEPMessage::ping_resp() const {
  return ping_resp_ != NULL ? *ping_resp_ : *default_instance_->ping_resp_;
}
inline ::MEPPingResp* MEPMessage::mutable_ping_resp() {
  set_has_ping_resp();
  if (ping_resp_ == NULL) ping_resp_ = new ::MEPPingResp;
  return ping_resp_;
}
inline ::MEPPingResp* MEPMessage::release_ping_resp() {
  clear_has_ping_resp();
  ::MEPPingResp* temp = ping_resp_;
  ping_resp_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_ping_resp(::MEPPingResp* ping_resp) {
  delete ping_resp_;
  ping_resp_ = ping_resp;
  if (ping_resp) {
    set_has_ping_resp();
  } else {
    clear_has_ping_resp();
  }
}

// optional .MEPEndSession end_session = 8;
inline bool MEPMessage::has_end_session() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MEPMessage::set_has_end_session() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MEPMessage::clear_has_end_session() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MEPMessage::clear_end_session() {
  if (end_session_ != NULL) end_session_->::MEPEndSession::Clear();
  clear_has_end_session();
}
inline const ::MEPEndSession& MEPMessage::end_session() const {
  return end_session_ != NULL ? *end_session_ : *default_instance_->end_session_;
}
inline ::MEPEndSession* MEPMessage::mutable_end_session() {
  set_has_end_session();
  if (end_session_ == NULL) end_session_ = new ::MEPEndSession;
  return end_session_;
}
inline ::MEPEndSession* MEPMessage::release_end_session() {
  clear_has_end_session();
  ::MEPEndSession* temp = end_session_;
  end_session_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_end_session(::MEPEndSession* end_session) {
  delete end_session_;
  end_session_ = end_session;
  if (end_session) {
    set_has_end_session();
  } else {
    clear_has_end_session();
  }
}

// optional .MEPIdentityInfos identity_infos = 9;
inline bool MEPMessage::has_identity_infos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MEPMessage::set_has_identity_infos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MEPMessage::clear_has_identity_infos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MEPMessage::clear_identity_infos() {
  if (identity_infos_ != NULL) identity_infos_->::MEPIdentityInfos::Clear();
  clear_has_identity_infos();
}
inline const ::MEPIdentityInfos& MEPMessage::identity_infos() const {
  return identity_infos_ != NULL ? *identity_infos_ : *default_instance_->identity_infos_;
}
inline ::MEPIdentityInfos* MEPMessage::mutable_identity_infos() {
  set_has_identity_infos();
  if (identity_infos_ == NULL) identity_infos_ = new ::MEPIdentityInfos;
  return identity_infos_;
}
inline ::MEPIdentityInfos* MEPMessage::release_identity_infos() {
  clear_has_identity_infos();
  ::MEPIdentityInfos* temp = identity_infos_;
  identity_infos_ = NULL;
  return temp;
}
inline void MEPMessage::set_allocated_identity_infos(::MEPIdentityInfos* identity_infos) {
  delete identity_infos_;
  identity_infos_ = identity_infos;
  if (identity_infos) {
    set_has_identity_infos();
  } else {
    clear_has_identity_infos();
  }
}

// -------------------------------------------------------------------

// MEPLoginRequest

// optional uint32 identity = 1;
inline bool MEPLoginRequest::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPLoginRequest::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPLoginRequest::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPLoginRequest::clear_identity() {
  identity_ = 0u;
  clear_has_identity();
}
inline ::google::protobuf::uint32 MEPLoginRequest::identity() const {
  return identity_;
}
inline void MEPLoginRequest::set_identity(::google::protobuf::uint32 value) {
  set_has_identity();
  identity_ = value;
}

// optional bytes token = 2;
inline bool MEPLoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MEPLoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MEPLoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MEPLoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& MEPLoginRequest::token() const {
  return *token_;
}
inline void MEPLoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void MEPLoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void MEPLoginRequest::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MEPLoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* MEPLoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MEPLoginRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tick = 3;
inline bool MEPLoginRequest::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MEPLoginRequest::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MEPLoginRequest::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MEPLoginRequest::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 MEPLoginRequest::tick() const {
  return tick_;
}
inline void MEPLoginRequest::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// MEPLoginResp

// optional int32 errcode = 1;
inline bool MEPLoginResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPLoginResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPLoginResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPLoginResp::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 MEPLoginResp::errcode() const {
  return errcode_;
}
inline void MEPLoginResp::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
}

// optional string public_addr = 2;
inline bool MEPLoginResp::has_public_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MEPLoginResp::set_has_public_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MEPLoginResp::clear_has_public_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MEPLoginResp::clear_public_addr() {
  if (public_addr_ != &::google::protobuf::internal::kEmptyString) {
    public_addr_->clear();
  }
  clear_has_public_addr();
}
inline const ::std::string& MEPLoginResp::public_addr() const {
  return *public_addr_;
}
inline void MEPLoginResp::set_public_addr(const ::std::string& value) {
  set_has_public_addr();
  if (public_addr_ == &::google::protobuf::internal::kEmptyString) {
    public_addr_ = new ::std::string;
  }
  public_addr_->assign(value);
}
inline void MEPLoginResp::set_public_addr(const char* value) {
  set_has_public_addr();
  if (public_addr_ == &::google::protobuf::internal::kEmptyString) {
    public_addr_ = new ::std::string;
  }
  public_addr_->assign(value);
}
inline void MEPLoginResp::set_public_addr(const char* value, size_t size) {
  set_has_public_addr();
  if (public_addr_ == &::google::protobuf::internal::kEmptyString) {
    public_addr_ = new ::std::string;
  }
  public_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MEPLoginResp::mutable_public_addr() {
  set_has_public_addr();
  if (public_addr_ == &::google::protobuf::internal::kEmptyString) {
    public_addr_ = new ::std::string;
  }
  return public_addr_;
}
inline ::std::string* MEPLoginResp::release_public_addr() {
  clear_has_public_addr();
  if (public_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_addr_;
    public_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MEPLoginResp::set_allocated_public_addr(::std::string* public_addr) {
  if (public_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete public_addr_;
  }
  if (public_addr) {
    set_has_public_addr();
    public_addr_ = public_addr;
  } else {
    clear_has_public_addr();
    public_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tick = 3;
inline bool MEPLoginResp::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MEPLoginResp::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MEPLoginResp::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MEPLoginResp::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 MEPLoginResp::tick() const {
  return tick_;
}
inline void MEPLoginResp::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// optional uint32 tick_delay = 4;
inline bool MEPLoginResp::has_tick_delay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MEPLoginResp::set_has_tick_delay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MEPLoginResp::clear_has_tick_delay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MEPLoginResp::clear_tick_delay() {
  tick_delay_ = 0u;
  clear_has_tick_delay();
}
inline ::google::protobuf::uint32 MEPLoginResp::tick_delay() const {
  return tick_delay_;
}
inline void MEPLoginResp::set_tick_delay(::google::protobuf::uint32 value) {
  set_has_tick_delay();
  tick_delay_ = value;
}

// -------------------------------------------------------------------

// MEPJoinSessionRequest

// optional bytes session_id = 1;
inline bool MEPJoinSessionRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPJoinSessionRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPJoinSessionRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPJoinSessionRequest::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& MEPJoinSessionRequest::session_id() const {
  return *session_id_;
}
inline void MEPJoinSessionRequest::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void MEPJoinSessionRequest::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void MEPJoinSessionRequest::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MEPJoinSessionRequest::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* MEPJoinSessionRequest::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MEPJoinSessionRequest::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MEPJoinSessionResp

// optional bytes session_id = 1;
inline bool MEPJoinSessionResp::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPJoinSessionResp::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPJoinSessionResp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPJoinSessionResp::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& MEPJoinSessionResp::session_id() const {
  return *session_id_;
}
inline void MEPJoinSessionResp::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void MEPJoinSessionResp::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void MEPJoinSessionResp::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MEPJoinSessionResp::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* MEPJoinSessionResp::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MEPJoinSessionResp::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 errcode = 2;
inline bool MEPJoinSessionResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MEPJoinSessionResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MEPJoinSessionResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MEPJoinSessionResp::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 MEPJoinSessionResp::errcode() const {
  return errcode_;
}
inline void MEPJoinSessionResp::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
}

// -------------------------------------------------------------------

// MEPPingRequest

// optional uint32 tick = 1;
inline bool MEPPingRequest::has_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPPingRequest::set_has_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPPingRequest::clear_has_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPPingRequest::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 MEPPingRequest::tick() const {
  return tick_;
}
inline void MEPPingRequest::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// MEPPingResp

// optional uint32 tick = 1;
inline bool MEPPingResp::has_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPPingResp::set_has_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPPingResp::clear_has_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPPingResp::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 MEPPingResp::tick() const {
  return tick_;
}
inline void MEPPingResp::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// optional uint32 delay = 2;
inline bool MEPPingResp::has_delay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MEPPingResp::set_has_delay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MEPPingResp::clear_has_delay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MEPPingResp::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 MEPPingResp::delay() const {
  return delay_;
}
inline void MEPPingResp::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// -------------------------------------------------------------------

// MEPEndSession

// optional uint32 streams = 1;
inline bool MEPEndSession::has_streams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MEPEndSession::set_has_streams() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MEPEndSession::clear_has_streams() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MEPEndSession::clear_streams() {
  streams_ = 0u;
  clear_has_streams();
}
inline ::google::protobuf::uint32 MEPEndSession::streams() const {
  return streams_;
}
inline void MEPEndSession::set_streams(::google::protobuf::uint32 value) {
  set_has_streams();
  streams_ = value;
}

// -------------------------------------------------------------------

// MEPIdentityInfos

// repeated uint32 identities = 1 [packed = true];
inline int MEPIdentityInfos::identities_size() const {
  return identities_.size();
}
inline void MEPIdentityInfos::clear_identities() {
  identities_.Clear();
}
inline ::google::protobuf::uint32 MEPIdentityInfos::identities(int index) const {
  return identities_.Get(index);
}
inline void MEPIdentityInfos::set_identities(int index, ::google::protobuf::uint32 value) {
  identities_.Set(index, value);
}
inline void MEPIdentityInfos::add_identities(::google::protobuf::uint32 value) {
  identities_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MEPIdentityInfos::identities() const {
  return identities_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MEPIdentityInfos::mutable_identities() {
  return &identities_;
}

// repeated string uids = 2;
inline int MEPIdentityInfos::uids_size() const {
  return uids_.size();
}
inline void MEPIdentityInfos::clear_uids() {
  uids_.Clear();
}
inline const ::std::string& MEPIdentityInfos::uids(int index) const {
  return uids_.Get(index);
}
inline ::std::string* MEPIdentityInfos::mutable_uids(int index) {
  return uids_.Mutable(index);
}
inline void MEPIdentityInfos::set_uids(int index, const ::std::string& value) {
  uids_.Mutable(index)->assign(value);
}
inline void MEPIdentityInfos::set_uids(int index, const char* value) {
  uids_.Mutable(index)->assign(value);
}
inline void MEPIdentityInfos::set_uids(int index, const char* value, size_t size) {
  uids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MEPIdentityInfos::add_uids() {
  return uids_.Add();
}
inline void MEPIdentityInfos::add_uids(const ::std::string& value) {
  uids_.Add()->assign(value);
}
inline void MEPIdentityInfos::add_uids(const char* value) {
  uids_.Add()->assign(value);
}
inline void MEPIdentityInfos::add_uids(const char* value, size_t size) {
  uids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MEPIdentityInfos::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MEPIdentityInfos::mutable_uids() {
  return &uids_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MEPMessage_2eproto__INCLUDED
