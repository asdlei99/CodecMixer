// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AVMixer2BizsMessage.proto

#ifndef PROTOBUF_AVMixer2BizsMessage_2eproto__INCLUDED
#define PROTOBUF_AVMixer2BizsMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

class CCNState;
class CCNLogin;
class CCNUser;
class CCNNotify;
class CCMigrationSessions;
class CCSessionReleaseNotify;
class CCNMessage;

// ===================================================================

class CCNState : public ::google::protobuf::Message {
 public:
  CCNState();
  virtual ~CCNState();

  CCNState(const CCNState& from);

  inline CCNState& operator=(const CCNState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNState& default_instance();

  void Swap(CCNState* other);

  // implements Message ----------------------------------------------

  CCNState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNState& from);
  void MergeFrom(const CCNState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uiCur = 1;
  inline bool has_uicur() const;
  inline void clear_uicur();
  static const int kUiCurFieldNumber = 1;
  inline ::google::protobuf::uint32 uicur() const;
  inline void set_uicur(::google::protobuf::uint32 value);

  // required uint32 uiMax = 2;
  inline bool has_uimax() const;
  inline void clear_uimax();
  static const int kUiMaxFieldNumber = 2;
  inline ::google::protobuf::uint32 uimax() const;
  inline void set_uimax(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CCNState)
 private:
  inline void set_has_uicur();
  inline void clear_has_uicur();
  inline void set_has_uimax();
  inline void clear_has_uimax();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uicur_;
  ::google::protobuf::uint32 uimax_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNState* default_instance_;
};
// -------------------------------------------------------------------

class CCNLogin : public ::google::protobuf::Message {
 public:
  CCNLogin();
  virtual ~CCNLogin();

  CCNLogin(const CCNLogin& from);

  inline CCNLogin& operator=(const CCNLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNLogin& default_instance();

  void Swap(CCNLogin* other);

  // implements Message ----------------------------------------------

  CCNLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNLogin& from);
  void MergeFrom(const CCNLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ccname = 1;
  inline bool has_ccname() const;
  inline void clear_ccname();
  static const int kCcnameFieldNumber = 1;
  inline const ::std::string& ccname() const;
  inline void set_ccname(const ::std::string& value);
  inline void set_ccname(const char* value);
  inline void set_ccname(const char* value, size_t size);
  inline ::std::string* mutable_ccname();
  inline ::std::string* release_ccname();
  inline void set_allocated_ccname(::std::string* ccname);

  // @@protoc_insertion_point(class_scope:CCNLogin)
 private:
  inline void set_has_ccname();
  inline void clear_has_ccname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ccname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNLogin* default_instance_;
};
// -------------------------------------------------------------------

class CCNUser : public ::google::protobuf::Message {
 public:
  CCNUser();
  virtual ~CCNUser();

  CCNUser(const CCNUser& from);

  inline CCNUser& operator=(const CCNUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNUser& default_instance();

  void Swap(CCNUser* other);

  // implements Message ----------------------------------------------

  CCNUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNUser& from);
  void MergeFrom(const CCNUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 identity = 2;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 2;
  inline ::google::protobuf::uint32 identity() const;
  inline void set_identity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CCNUser)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_identity();
  inline void clear_has_identity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 identity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNUser* default_instance_;
};
// -------------------------------------------------------------------

class CCNNotify : public ::google::protobuf::Message {
 public:
  CCNNotify();
  virtual ~CCNNotify();

  CCNNotify(const CCNNotify& from);

  inline CCNNotify& operator=(const CCNNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNNotify& default_instance();

  void Swap(CCNNotify* other);

  // implements Message ----------------------------------------------

  CCNNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNNotify& from);
  void MergeFrom(const CCNNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline const ::std::string& sessionid() const;
  inline void set_sessionid(const ::std::string& value);
  inline void set_sessionid(const char* value);
  inline void set_sessionid(const void* value, size_t size);
  inline ::std::string* mutable_sessionid();
  inline ::std::string* release_sessionid();
  inline void set_allocated_sessionid(::std::string* sessionid);

  // optional string config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // repeated .CCNUser user = 3;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::CCNUser& user(int index) const;
  inline ::CCNUser* mutable_user(int index);
  inline ::CCNUser* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::CCNUser >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::CCNUser >*
      mutable_user();

  // required uint32 timeout = 4;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CCNNotify)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sessionid_;
  ::std::string* config_;
  ::google::protobuf::RepeatedPtrField< ::CCNUser > user_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNNotify* default_instance_;
};
// -------------------------------------------------------------------

class CCMigrationSessions : public ::google::protobuf::Message {
 public:
  CCMigrationSessions();
  virtual ~CCMigrationSessions();

  CCMigrationSessions(const CCMigrationSessions& from);

  inline CCMigrationSessions& operator=(const CCMigrationSessions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCMigrationSessions& default_instance();

  void Swap(CCMigrationSessions* other);

  // implements Message ----------------------------------------------

  CCMigrationSessions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCMigrationSessions& from);
  void MergeFrom(const CCMigrationSessions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes session = 1;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::std::string& session(int index) const;
  inline ::std::string* mutable_session(int index);
  inline void set_session(int index, const ::std::string& value);
  inline void set_session(int index, const char* value);
  inline void set_session(int index, const void* value, size_t size);
  inline ::std::string* add_session();
  inline void add_session(const ::std::string& value);
  inline void add_session(const char* value);
  inline void add_session(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& session() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_session();

  // @@protoc_insertion_point(class_scope:CCMigrationSessions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCMigrationSessions* default_instance_;
};
// -------------------------------------------------------------------

class CCSessionReleaseNotify : public ::google::protobuf::Message {
 public:
  CCSessionReleaseNotify();
  virtual ~CCSessionReleaseNotify();

  CCSessionReleaseNotify(const CCSessionReleaseNotify& from);

  inline CCSessionReleaseNotify& operator=(const CCSessionReleaseNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCSessionReleaseNotify& default_instance();

  void Swap(CCSessionReleaseNotify* other);

  // implements Message ----------------------------------------------

  CCSessionReleaseNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCSessionReleaseNotify& from);
  void MergeFrom(const CCSessionReleaseNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline const ::std::string& sessionid() const;
  inline void set_sessionid(const ::std::string& value);
  inline void set_sessionid(const char* value);
  inline void set_sessionid(const void* value, size_t size);
  inline ::std::string* mutable_sessionid();
  inline ::std::string* release_sessionid();
  inline void set_allocated_sessionid(::std::string* sessionid);

  // @@protoc_insertion_point(class_scope:CCSessionReleaseNotify)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCSessionReleaseNotify* default_instance_;
};
// -------------------------------------------------------------------

class CCNMessage : public ::google::protobuf::Message {
 public:
  CCNMessage();
  virtual ~CCNMessage();

  CCNMessage(const CCNMessage& from);

  inline CCNMessage& operator=(const CCNMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCNMessage& default_instance();

  void Swap(CCNMessage* other);

  // implements Message ----------------------------------------------

  CCNMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCNMessage& from);
  void MergeFrom(const CCNMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CCNState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::CCNState& state() const;
  inline ::CCNState* mutable_state();
  inline ::CCNState* release_state();
  inline void set_allocated_state(::CCNState* state);

  // optional .CCNNotify notify = 2;
  inline bool has_notify() const;
  inline void clear_notify();
  static const int kNotifyFieldNumber = 2;
  inline const ::CCNNotify& notify() const;
  inline ::CCNNotify* mutable_notify();
  inline ::CCNNotify* release_notify();
  inline void set_allocated_notify(::CCNNotify* notify);

  // optional .CCMigrationSessions migrate_sessions = 3;
  inline bool has_migrate_sessions() const;
  inline void clear_migrate_sessions();
  static const int kMigrateSessionsFieldNumber = 3;
  inline const ::CCMigrationSessions& migrate_sessions() const;
  inline ::CCMigrationSessions* mutable_migrate_sessions();
  inline ::CCMigrationSessions* release_migrate_sessions();
  inline void set_allocated_migrate_sessions(::CCMigrationSessions* migrate_sessions);

  // optional .CCSessionReleaseNotify session_release_notify = 4;
  inline bool has_session_release_notify() const;
  inline void clear_session_release_notify();
  static const int kSessionReleaseNotifyFieldNumber = 4;
  inline const ::CCSessionReleaseNotify& session_release_notify() const;
  inline ::CCSessionReleaseNotify* mutable_session_release_notify();
  inline ::CCSessionReleaseNotify* release_session_release_notify();
  inline void set_allocated_session_release_notify(::CCSessionReleaseNotify* session_release_notify);

  // optional .CCNLogin login = 5;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 5;
  inline const ::CCNLogin& login() const;
  inline ::CCNLogin* mutable_login();
  inline ::CCNLogin* release_login();
  inline void set_allocated_login(::CCNLogin* login);

  // @@protoc_insertion_point(class_scope:CCNMessage)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_notify();
  inline void clear_has_notify();
  inline void set_has_migrate_sessions();
  inline void clear_has_migrate_sessions();
  inline void set_has_session_release_notify();
  inline void clear_has_session_release_notify();
  inline void set_has_login();
  inline void clear_has_login();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CCNState* state_;
  ::CCNNotify* notify_;
  ::CCMigrationSessions* migrate_sessions_;
  ::CCSessionReleaseNotify* session_release_notify_;
  ::CCNLogin* login_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_AssignDesc_AVMixer2BizsMessage_2eproto();
  friend void protobuf_ShutdownFile_AVMixer2BizsMessage_2eproto();

  void InitAsDefaultInstance();
  static CCNMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// CCNState

// required uint32 uiCur = 1;
inline bool CCNState::has_uicur() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNState::set_has_uicur() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNState::clear_has_uicur() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNState::clear_uicur() {
  uicur_ = 0u;
  clear_has_uicur();
}
inline ::google::protobuf::uint32 CCNState::uicur() const {
  return uicur_;
}
inline void CCNState::set_uicur(::google::protobuf::uint32 value) {
  set_has_uicur();
  uicur_ = value;
}

// required uint32 uiMax = 2;
inline bool CCNState::has_uimax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNState::set_has_uimax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNState::clear_has_uimax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNState::clear_uimax() {
  uimax_ = 0u;
  clear_has_uimax();
}
inline ::google::protobuf::uint32 CCNState::uimax() const {
  return uimax_;
}
inline void CCNState::set_uimax(::google::protobuf::uint32 value) {
  set_has_uimax();
  uimax_ = value;
}

// -------------------------------------------------------------------

// CCNLogin

// required string ccname = 1;
inline bool CCNLogin::has_ccname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNLogin::set_has_ccname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNLogin::clear_has_ccname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNLogin::clear_ccname() {
  if (ccname_ != &::google::protobuf::internal::kEmptyString) {
    ccname_->clear();
  }
  clear_has_ccname();
}
inline const ::std::string& CCNLogin::ccname() const {
  return *ccname_;
}
inline void CCNLogin::set_ccname(const ::std::string& value) {
  set_has_ccname();
  if (ccname_ == &::google::protobuf::internal::kEmptyString) {
    ccname_ = new ::std::string;
  }
  ccname_->assign(value);
}
inline void CCNLogin::set_ccname(const char* value) {
  set_has_ccname();
  if (ccname_ == &::google::protobuf::internal::kEmptyString) {
    ccname_ = new ::std::string;
  }
  ccname_->assign(value);
}
inline void CCNLogin::set_ccname(const char* value, size_t size) {
  set_has_ccname();
  if (ccname_ == &::google::protobuf::internal::kEmptyString) {
    ccname_ = new ::std::string;
  }
  ccname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNLogin::mutable_ccname() {
  set_has_ccname();
  if (ccname_ == &::google::protobuf::internal::kEmptyString) {
    ccname_ = new ::std::string;
  }
  return ccname_;
}
inline ::std::string* CCNLogin::release_ccname() {
  clear_has_ccname();
  if (ccname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ccname_;
    ccname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNLogin::set_allocated_ccname(::std::string* ccname) {
  if (ccname_ != &::google::protobuf::internal::kEmptyString) {
    delete ccname_;
  }
  if (ccname) {
    set_has_ccname();
    ccname_ = ccname;
  } else {
    clear_has_ccname();
    ccname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CCNUser

// optional string uid = 1;
inline bool CCNUser::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNUser::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNUser::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNUser::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CCNUser::uid() const {
  return *uid_;
}
inline void CCNUser::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CCNUser::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CCNUser::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNUser::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CCNUser::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNUser::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 identity = 2;
inline bool CCNUser::has_identity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNUser::set_has_identity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNUser::clear_has_identity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNUser::clear_identity() {
  identity_ = 0u;
  clear_has_identity();
}
inline ::google::protobuf::uint32 CCNUser::identity() const {
  return identity_;
}
inline void CCNUser::set_identity(::google::protobuf::uint32 value) {
  set_has_identity();
  identity_ = value;
}

// -------------------------------------------------------------------

// CCNNotify

// required bytes sessionid = 1;
inline bool CCNNotify::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNNotify::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNNotify::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNNotify::clear_sessionid() {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    sessionid_->clear();
  }
  clear_has_sessionid();
}
inline const ::std::string& CCNNotify::sessionid() const {
  return *sessionid_;
}
inline void CCNNotify::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void CCNNotify::set_sessionid(const char* value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void CCNNotify::set_sessionid(const void* value, size_t size) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNNotify::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  return sessionid_;
}
inline ::std::string* CCNNotify::release_sessionid() {
  clear_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionid_;
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNNotify::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionid_;
  }
  if (sessionid) {
    set_has_sessionid();
    sessionid_ = sessionid;
  } else {
    clear_has_sessionid();
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string config = 2;
inline bool CCNNotify::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNNotify::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNNotify::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNNotify::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& CCNNotify::config() const {
  return *config_;
}
inline void CCNNotify::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void CCNNotify::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void CCNNotify::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCNNotify::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* CCNNotify::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCNNotify::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .CCNUser user = 3;
inline int CCNNotify::user_size() const {
  return user_.size();
}
inline void CCNNotify::clear_user() {
  user_.Clear();
}
inline const ::CCNUser& CCNNotify::user(int index) const {
  return user_.Get(index);
}
inline ::CCNUser* CCNNotify::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::CCNUser* CCNNotify::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CCNUser >&
CCNNotify::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::CCNUser >*
CCNNotify::mutable_user() {
  return &user_;
}

// required uint32 timeout = 4;
inline bool CCNNotify::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CCNNotify::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CCNNotify::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CCNNotify::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 CCNNotify::timeout() const {
  return timeout_;
}
inline void CCNNotify::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// CCMigrationSessions

// repeated bytes session = 1;
inline int CCMigrationSessions::session_size() const {
  return session_.size();
}
inline void CCMigrationSessions::clear_session() {
  session_.Clear();
}
inline const ::std::string& CCMigrationSessions::session(int index) const {
  return session_.Get(index);
}
inline ::std::string* CCMigrationSessions::mutable_session(int index) {
  return session_.Mutable(index);
}
inline void CCMigrationSessions::set_session(int index, const ::std::string& value) {
  session_.Mutable(index)->assign(value);
}
inline void CCMigrationSessions::set_session(int index, const char* value) {
  session_.Mutable(index)->assign(value);
}
inline void CCMigrationSessions::set_session(int index, const void* value, size_t size) {
  session_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCMigrationSessions::add_session() {
  return session_.Add();
}
inline void CCMigrationSessions::add_session(const ::std::string& value) {
  session_.Add()->assign(value);
}
inline void CCMigrationSessions::add_session(const char* value) {
  session_.Add()->assign(value);
}
inline void CCMigrationSessions::add_session(const void* value, size_t size) {
  session_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CCMigrationSessions::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CCMigrationSessions::mutable_session() {
  return &session_;
}

// -------------------------------------------------------------------

// CCSessionReleaseNotify

// required bytes sessionid = 1;
inline bool CCSessionReleaseNotify::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCSessionReleaseNotify::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCSessionReleaseNotify::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCSessionReleaseNotify::clear_sessionid() {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    sessionid_->clear();
  }
  clear_has_sessionid();
}
inline const ::std::string& CCSessionReleaseNotify::sessionid() const {
  return *sessionid_;
}
inline void CCSessionReleaseNotify::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void CCSessionReleaseNotify::set_sessionid(const char* value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void CCSessionReleaseNotify::set_sessionid(const void* value, size_t size) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCSessionReleaseNotify::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  return sessionid_;
}
inline ::std::string* CCSessionReleaseNotify::release_sessionid() {
  clear_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionid_;
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCSessionReleaseNotify::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionid_;
  }
  if (sessionid) {
    set_has_sessionid();
    sessionid_ = sessionid;
  } else {
    clear_has_sessionid();
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CCNMessage

// optional .CCNState state = 1;
inline bool CCNMessage::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCNMessage::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCNMessage::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCNMessage::clear_state() {
  if (state_ != NULL) state_->::CCNState::Clear();
  clear_has_state();
}
inline const ::CCNState& CCNMessage::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::CCNState* CCNMessage::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::CCNState;
  return state_;
}
inline ::CCNState* CCNMessage::release_state() {
  clear_has_state();
  ::CCNState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_state(::CCNState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .CCNNotify notify = 2;
inline bool CCNMessage::has_notify() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCNMessage::set_has_notify() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCNMessage::clear_has_notify() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCNMessage::clear_notify() {
  if (notify_ != NULL) notify_->::CCNNotify::Clear();
  clear_has_notify();
}
inline const ::CCNNotify& CCNMessage::notify() const {
  return notify_ != NULL ? *notify_ : *default_instance_->notify_;
}
inline ::CCNNotify* CCNMessage::mutable_notify() {
  set_has_notify();
  if (notify_ == NULL) notify_ = new ::CCNNotify;
  return notify_;
}
inline ::CCNNotify* CCNMessage::release_notify() {
  clear_has_notify();
  ::CCNNotify* temp = notify_;
  notify_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_notify(::CCNNotify* notify) {
  delete notify_;
  notify_ = notify;
  if (notify) {
    set_has_notify();
  } else {
    clear_has_notify();
  }
}

// optional .CCMigrationSessions migrate_sessions = 3;
inline bool CCNMessage::has_migrate_sessions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CCNMessage::set_has_migrate_sessions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CCNMessage::clear_has_migrate_sessions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CCNMessage::clear_migrate_sessions() {
  if (migrate_sessions_ != NULL) migrate_sessions_->::CCMigrationSessions::Clear();
  clear_has_migrate_sessions();
}
inline const ::CCMigrationSessions& CCNMessage::migrate_sessions() const {
  return migrate_sessions_ != NULL ? *migrate_sessions_ : *default_instance_->migrate_sessions_;
}
inline ::CCMigrationSessions* CCNMessage::mutable_migrate_sessions() {
  set_has_migrate_sessions();
  if (migrate_sessions_ == NULL) migrate_sessions_ = new ::CCMigrationSessions;
  return migrate_sessions_;
}
inline ::CCMigrationSessions* CCNMessage::release_migrate_sessions() {
  clear_has_migrate_sessions();
  ::CCMigrationSessions* temp = migrate_sessions_;
  migrate_sessions_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_migrate_sessions(::CCMigrationSessions* migrate_sessions) {
  delete migrate_sessions_;
  migrate_sessions_ = migrate_sessions;
  if (migrate_sessions) {
    set_has_migrate_sessions();
  } else {
    clear_has_migrate_sessions();
  }
}

// optional .CCSessionReleaseNotify session_release_notify = 4;
inline bool CCNMessage::has_session_release_notify() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CCNMessage::set_has_session_release_notify() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CCNMessage::clear_has_session_release_notify() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CCNMessage::clear_session_release_notify() {
  if (session_release_notify_ != NULL) session_release_notify_->::CCSessionReleaseNotify::Clear();
  clear_has_session_release_notify();
}
inline const ::CCSessionReleaseNotify& CCNMessage::session_release_notify() const {
  return session_release_notify_ != NULL ? *session_release_notify_ : *default_instance_->session_release_notify_;
}
inline ::CCSessionReleaseNotify* CCNMessage::mutable_session_release_notify() {
  set_has_session_release_notify();
  if (session_release_notify_ == NULL) session_release_notify_ = new ::CCSessionReleaseNotify;
  return session_release_notify_;
}
inline ::CCSessionReleaseNotify* CCNMessage::release_session_release_notify() {
  clear_has_session_release_notify();
  ::CCSessionReleaseNotify* temp = session_release_notify_;
  session_release_notify_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_session_release_notify(::CCSessionReleaseNotify* session_release_notify) {
  delete session_release_notify_;
  session_release_notify_ = session_release_notify;
  if (session_release_notify) {
    set_has_session_release_notify();
  } else {
    clear_has_session_release_notify();
  }
}

// optional .CCNLogin login = 5;
inline bool CCNMessage::has_login() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CCNMessage::set_has_login() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CCNMessage::clear_has_login() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CCNMessage::clear_login() {
  if (login_ != NULL) login_->::CCNLogin::Clear();
  clear_has_login();
}
inline const ::CCNLogin& CCNMessage::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::CCNLogin* CCNMessage::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::CCNLogin;
  return login_;
}
inline ::CCNLogin* CCNMessage::release_login() {
  clear_has_login();
  ::CCNLogin* temp = login_;
  login_ = NULL;
  return temp;
}
inline void CCNMessage::set_allocated_login(::CCNLogin* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AVMixer2BizsMessage_2eproto__INCLUDED
